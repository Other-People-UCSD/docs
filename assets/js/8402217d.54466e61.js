"use strict";(self.webpackChunkopm_documentation=self.webpackChunkopm_documentation||[]).push([[8303],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=c(n),u=i,m=h["".concat(l,".").concat(u)]||h[u]||p[u]||o;return n?a.createElement(m,r(r({ref:t},d),{},{components:n})):a.createElement(m,r({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7116:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={title:"Architecture",sidebar_position:2,contributor:"Kevin Jang"},r="Architecture",s={unversionedId:"calla-lily/architecture",id:"calla-lily/architecture",title:"Architecture",description:"A top-level view of the website's architecture and most important dependencies.",source:"@site/docs/calla-lily/02-architecture.md",sourceDirName:"calla-lily",slug:"/calla-lily/architecture",permalink:"/docs/calla-lily/architecture",draft:!1,editUrl:"https://github.com/Other-People-UCSD/docs/tree/main/docs/calla-lily/02-architecture.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Architecture",sidebar_position:2,contributor:"Kevin Jang"},sidebar:"docsSidebar",previous:{title:"Getting Started",permalink:"/docs/calla-lily/getting-started"},next:{title:"Rebuild Release Notes",permalink:"/docs/calla-lily/calla-lily-release"}},l={},c=[{value:"Headless CMS: TinaCMS",id:"headless-cms-tinacms",level:2},{value:"Static Site Generation using Next.js and Vercel",id:"static-site-generation-using-nextjs-and-vercel",level:2},{value:"GitHub Repository Map",id:"github-repository-map",level:2}],d={toc:c},h="wrapper";function p(e){let{components:t,...o}=e;return(0,i.kt)(h,(0,a.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"architecture"},"Architecture"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"A top-level view of the website&#39;s architecture and most important dependencies.",src:n(7209).Z,width:"900",height:"621"})),(0,i.kt)("p",null,"The organization uses GitHub as a codebase for version control, data storage, and collaboration with other developers on the team for the budget available. The website is built in React because this allows it to be able to interact with many modern headless CMSes like TinaCMS for live editing functionality which a vanilla JS website would not be able to do. Next.js is the web framework that generates the website and its parent company Vercel is used for deployment because of first-class support for Next.js websites. "),(0,i.kt)("h2",{id:"headless-cms-tinacms"},"Headless CMS: TinaCMS"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"System Diagram of the TinaCMS Headless CMS",src:n(841).Z,width:"1652",height:"1028"})),(0,i.kt)("p",null,"A headless CMS is a content management system where the content is separate from the interface with which it is managed by the editor. Developers use the API provided by the headless CMS to query the content into the interface and build interactivity. OPM's website uses the TinaCMS headless CMS to give our editors a simple UI with support for live editing while our developers benefit by maintaining the artistic integrity of custom-coded posts that cannot be done by a traditional CMS model. "),(0,i.kt)("p",null,"This system diagram depicts how TinaCMS interacts with the data and editors. On the data side, the Github-stored dataset uses the React and Next.js frameworks to create the functional pages for posts. The Tina schema file must be defined by the developer to denote what data Tina is able to access. Only pages and their specified fields are able to be modified by TinaCMS, protecting other files from being modified by the CMS and other web producers who may accidentally cause a breaking change. The dashed line separates the data with the mounted CMS by using the useTina hook connection. This allows TinaCMS to query data from the dataset and autogenerate GraphQL nodes and functions to be used in the API. When the website gets built to deployment, the data evaluated in the Tina API is what will be displayed on the webpage through the getStaticPaths function that will generate the rendered pages."),(0,i.kt)("p",null,"On the editor side, web producers must access the production site and log in through Tina's built-in authentication system which prevents outside adversaries from gaining control of the CMS. Once authenticated, producers will by able to view posts through the Tina Cloud UI. Tina Cloud is a remote view of the dataset independent of the stored dataset in GitHub. This means that edits on the remote Tina Cloud will not automatically show up on the rendered website until they push the change to the remote repository. This is accomplished through a webhook connection from Tina Cloud to the GitHub repository to sync edits on the cloud to the repository."),(0,i.kt)("h2",{id:"static-site-generation-using-nextjs-and-vercel"},"Static Site Generation using Next.js and Vercel"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"System Diagram of templating, static site generator, and server side rendering.",src:n(9725).Z,width:"1473",height:"896"})),(0,i.kt)("p",null,"Next.js is a framework used to build web applications. Built upon React, this allows Next.js to use HTML templates in the form of JSX to create HTML pages for the client. The templated files are composed of smaller components usually kept within the ",(0,i.kt)("inlineCode",{parentName:"p"},"components")," directory and also the main content components within the ",(0,i.kt)("inlineCode",{parentName:"p"},"pages")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"_posts")," directories. "),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The search script requires the metadata of posts in order to work. To keep the pages within SSG for fast loading as compared to SSR, each page that uses the search must get the post metadata. However, the data is not fetched as a state variable in the search file but at the top-level ",(0,i.kt)("inlineCode",{parentName:"p"},"_app.js")," file. To pass down the data without making a long dependency chain through files, a React context is used to directly access the data within ",(0,i.kt)("inlineCode",{parentName:"p"},"search.js"),".")),(0,i.kt)("p",null,"The bottom-left block is the pipeline for how content from Markdown-HTML (MDX) files gets parsed into HTML for the static site generator (SSG). The data is not in fact accessed through Next.js as it has to be run through the TinaCMS connection for the live preview editor feature to work. We used a custom-built parser based off the ",(0,i.kt)("inlineCode",{parentName:"p"},"<TinaMarkdown />")," component that TinaCMS uses in order to satisfy our use case. "),(0,i.kt)("p",null,"The dynamic router is meant to create static paths for each posts without manually creating JS files for each one unlike the landing pages. Please read the Next.js documentation on dynamic routing and view the source code in ",(0,i.kt)("inlineCode",{parentName:"p"},"[...slug].js")," to see how the router is made. The templated HTML with parsed HTML and dynamic routes are all sent into the Next.js CL/CI pipeline for static site generation where images and third-party scripts will be optimized using Next.js's functions. "),(0,i.kt)("p",null,"In addition to SSG, server-side rendering (SSR) occurs to create API endpoints for both future data connections and also research. This API will function properly because the website is deployed on Vercel which has first-class support for SSR by converting the pages into serverless functions."),(0,i.kt)("h2",{id:"github-repository-map"},"GitHub Repository Map"),(0,i.kt)("p",null,"This is an overview of important files and folders in the repository. Many of these have been shown in the website architecture for a more visual reference as to how they are used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"/\n| \n\u251c\u2500\u2500 _posts              # Published posts, organized into folders\n|\n\u251c\u2500\u2500 components          # Building blocks for webpages\n\u251c\u2500\u2500 lib                 # Helper functions that run the backend of the framework\n|\n\u251c\u2500\u2500 data                # Centralized JSON files used to modify multiple pages together\n\u251c\u2500\u2500 pages               # The pages that are compiled and deployed on the website\n|   \u251c\u2500\u2500 _app.js         # The container for all components\n|   \u251c\u2500\u2500 _document.js    # Updates the html and body tags\n|   \u251c\u2500\u2500 index.js        # Homepage\n|   \u251c\u2500\u2500 [...slug].js    # Dynamic router to build all posts in _posts\n|   \u2514\u2500\u2500 api             # API Routing Endpoints\n|\n\u251c\u2500\u2500 styles              # CSS using CSS Modules and SASS\n\u251c\u2500\u2500 public              # Styling the website\n|   \u251c\u2500\u2500 favicons        # Other People Logo\n|   \u251c\u2500\u2500 fonts           # Basier Mono Circle\n|   \u251c\u2500\u2500 images          # Folder for media and images, organized into folders\n|   \u251c\u2500\u2500 js              # Functionality for interactive elements\n|   |\n|   \u2514\u2500\u2500 production      # Autogenerated TinaCMS route for content editing \n\u251c\u2500\u2500 tina                # TinaCMS configuration and schema\n|\n\u2514\u2500\u2500 next.config.js      # Configuration for Next.JS framework\n")))}p.isMDXComponent=!0},841:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/headless-cms-architecture-83872ba8a1ab02d3ed6b03eee4b6c05f.png"},9725:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/ssg-architecture-b6a3639c4dc702abc880f4b42e6a9d7d.png"},7209:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/top-level-architecture-630c9cf2ad2fc434f1ee81cf948ef21f.png"}}]);