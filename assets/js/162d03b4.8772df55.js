"use strict";(self.webpackChunkopm_documentation=self.webpackChunkopm_documentation||[]).push([[9630],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=c(n),u=o,m=p["".concat(l,".").concat(u)]||p[u]||d[u]||i;return n?a.createElement(m,r(r({ref:t},h),{},{components:n})):a.createElement(m,r({ref:t},h))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1528:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const i={title:"Search and Displaying Recommendations",sidebar_position:8,contributor:"Kevin Jang"},r=void 0,s={unversionedId:"calla-lily/search",id:"calla-lily/search",title:"Search and Displaying Recommendations",description:"The search function in Pink-Currents used a dependency on Jekyll that got the data from posts and used that to filter results. Since Calla-Lily cannot use that dependency, we ended up building a custom search function to do this operation.",source:"@site/docs/calla-lily/08-search.md",sourceDirName:"calla-lily",slug:"/calla-lily/search",permalink:"/docs/calla-lily/search",draft:!1,editUrl:"https://github.com/Other-People-UCSD/docs/tree/main/docs/calla-lily/08-search.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{title:"Search and Displaying Recommendations",sidebar_position:8,contributor:"Kevin Jang"},sidebar:"docsSidebar",previous:{title:"API Endpoints",permalink:"/docs/calla-lily/api"},next:{title:"Testing",permalink:"/docs/calla-lily/testing"}},l={},c=[{value:"Improving Search in the Future",id:"improving-search-in-the-future",level:2},{value:"Advanced Search (2024)",id:"advanced-search-2024",level:2},{value:"Data Modeling",id:"data-modeling",level:3},{value:"Feeding Data to Search Component (2023)",id:"feeding-data-to-search-component-2023",level:2},{value:"Displaying Recommendations (...slug.js only)",id:"displaying-recommendations-slugjs-only",level:2}],h={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The search function in Pink-Currents used a dependency on Jekyll that got the data from posts and used that to filter results. Since Calla-Lily cannot use that dependency, we ended up building a custom search function to do this operation."),(0,o.kt)("p",null,"At a high-level, the program uses the collection or category number, title, contributor(s), and tags as queries to filter on. It generates a list of up to ten works per page that match the search query."),(0,o.kt)("h2",{id:"improving-search-in-the-future"},"Improving Search in the Future"),(0,o.kt)("p",null,"Ideally search should be implemented on the server-side using data indexing for fastest performance and simpler maintenance. Because the data is filtered on the private server, the search query could match on the textual content of copyrighted works. There will not be data leakage as this textual content is not exposed to the client in the API response. The API response would only contain the data that would be displayed to the user, such as the title, contributor, and genre."),(0,o.kt)("h2",{id:"advanced-search-2024"},"Advanced Search (2024)"),(0,o.kt)("p",null,"The new UI/UX implements a search and filter component that does not rely on Next.js passing of data through ",(0,o.kt)("inlineCode",{parentName:"p"},"getStaticProps"),". Instead, it utilizes the native API to fetch the data for the posts once the user opens the search bar. This has its tradeoffs, but improves scalability maintenance and conserves a negligible amount of space because the data is requested on-demand instead of all the time. The search must address network performance which can be done by using a data loaded state."),(0,o.kt)("p",null,'The filter should scale well for several years until there are over twenty collections or content years of data. Then the UI should be modified to either do a lookup for valid options or use a "show more" button to display additional filter inputs. '),(0,o.kt)("p",null,"This filter uses conditional logic to achieve its function. Since collections and content years are mutually exclusive groups, their filtered results should be disjunctive. In addition, a user may want to filter by the genre of works. The genre may or may not include works from collections and content years, so this is a conjunctive field. Then the conditional logic becomes ",(0,o.kt)("inlineCode",{parentName:"p"},"GENRE AND (COLLECTION OR CONTENT_YEAR)"),". For the initial state of the filter the logic is ",(0,o.kt)("inlineCode",{parentName:"p"},"(HAS TAGS AND NOT GENRE) AND NOT COLLECTION AND NOT CONTENT_YEAR")," due to how the data is compared."),(0,o.kt)("p",null,"Results are paginated to ten results with a navigation bar at the bottom to show more matching results. We also use text highlighting on the title and contributors to show how the query matches the result item."),(0,o.kt)("h3",{id:"data-modeling"},"Data Modeling"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'metadata = {\n    "years": ["2020", "2021", ... , "2024"],\n    "collections:" ["1", "2", ... , "6"],\n    "/2023/hole": { "slug", "wordCount", "title", "contributors", "date", "tags", "thumbnail" , "excerpt" },\n    "/1/fire": Object<Metadata>\n}\n')),(0,o.kt)("h2",{id:"feeding-data-to-search-component-2023"},"Feeding Data to Search Component (2023)"),(0,o.kt)("p",null,"The main problems to make the search function work was getting the information needed to filter results from. First, only the ",(0,o.kt)("inlineCode",{parentName:"p"},"[...slug].js")," pages contained the data which meant landing pages could not show search results. In addition, is there an easier way to pass the props from the ",(0,o.kt)("inlineCode",{parentName:"p"},"pages/app.js")," file where all props are kept all the way to the ",(0,o.kt)("inlineCode",{parentName:"p"},"components/search.js")," file?"),(0,o.kt)("p",null,"To solve the first problem, we have to get all of the post data and set it onto every page where search is enabled. This is done through creating a ",(0,o.kt)("inlineCode",{parentName:"p"},"getStaticProps")," function onto each of these pages and they will store the same post information as ",(0,o.kt)("inlineCode",{parentName:"p"},"[...slug].js")," via the ",(0,o.kt)("inlineCode",{parentName:"p"},"getSortedPostsData")," function in ",(0,o.kt)("inlineCode",{parentName:"p"},"lib/posts.js"),". All of these pages will then have the prop ",(0,o.kt)("inlineCode",{parentName:"p"},"props.allPostsData = getSortedPostsData()"),". This solution means that any new page with a search bar will have to reuse the ",(0,o.kt)("inlineCode",{parentName:"p"},"getStaticProps")," function from one of these posts."),(0,o.kt)("p",null,"The latter problem is an architectural problem which can be solved naively by brute-force passing the prop down the top-level until it reaches the search component as ",(0,o.kt)("inlineCode",{parentName:"p"},"<App> -> <Document> -> <Layout> -> <Header> -> <MobileNav> -> <Search>"),". "),(0,o.kt)("p",null,"There is a more ingenious approach by utilizing React's ",(0,o.kt)("inlineCode",{parentName:"p"},"useContext")," hook. Context in a React app is the process of making a variable in a parent component available to any of its children no matter how deep it is in the component tree. The benefit of the context is that the variable does not need to explicitly passed through each of these children components. "),(0,o.kt)("p",null,"To do this, we wrap the children component of ",(0,o.kt)("inlineCode",{parentName:"p"},"<App>")," with the context defined in ",(0,o.kt)("inlineCode",{parentName:"p"},"components/appContext.js"),". This wrapper creates a context only with the variables necessary so as to not cause bandwidth overhead passing in unused variables. Then the ",(0,o.kt)("inlineCode",{parentName:"p"},"useAppContext")," function can be called from any child component such as ",(0,o.kt)("inlineCode",{parentName:"p"},"<Search>")," to receive the variables saved in the context. This is how the collection of sorted post data and recommendation data is passed to the search component."),(0,o.kt)("h2",{id:"displaying-recommendations-slugjs-only"},"Displaying Recommendations (","[...slug]",".js only)"),(0,o.kt)("p",null,"If there are recommendation results for a work, they will be fed through the ",(0,o.kt)("inlineCode",{parentName:"p"},"getStaticProps")," function. The app context as explained in the previous section will save this prop into the state and feed it down to the search component. Then the recommendations are displayed under the search in this priority."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"If there is nothing typed in the search query and there are recommendations, display the top 10 recommendations."),(0,o.kt)("li",{parentName:"ol"},"If there is something typed in the search query, display the top 10 search results."),(0,o.kt)("li",{parentName:"ol"},"If there is nothing typed in the search query and no recommendation results, display the 10 most recent works published.")))}d.isMDXComponent=!0}}]);