"use strict";(self.webpackChunkopm_documentation=self.webpackChunkopm_documentation||[]).push([[390],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>m});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},h=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=d(a),u=i,m=p["".concat(l,".").concat(u)]||p[u]||c[u]||r;return a?n.createElement(m,o(o({ref:t},h),{},{components:a})):n.createElement(m,o({ref:t},h))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,o[1]=s;for(var d=2;d<r;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},4573:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var n=a(7462),i=(a(7294),a(3905));const r={title:"Data Layer",sidebar_position:2,contributor:"Kevin Jang"},o=void 0,s={unversionedId:"calla-lily/data-layer",id:"calla-lily/data-layer",title:"Data Layer",description:"This page assumes you have read through the Schema document.",source:"@site/docs/calla-lily/data-layer.md",sourceDirName:"calla-lily",slug:"/calla-lily/data-layer",permalink:"/docs/calla-lily/data-layer",draft:!1,editUrl:"https://github.com/Other-People-UCSD/docs/tree/main/docs/calla-lily/data-layer.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Data Layer",sidebar_position:2,contributor:"Kevin Jang"},sidebar:"docsSidebar",previous:{title:"Post Schema & Data",permalink:"/docs/calla-lily/schema"},next:{title:"Rebuild Release Notes",permalink:"/docs/calla-lily/calla-lily-release"}},l={},d=[{value:"Data in Next.js",id:"data-in-nextjs",level:2},{value:"Reading Data",id:"reading-data",level:3},{value:"Parsing",id:"parsing",level:3},{value:"Data in TinaCMS",id:"data-in-tinacms",level:2},{value:"Reading Data: GraphQL",id:"reading-data-graphql",level:3},{value:"Parsing",id:"parsing-1",level:3},{value:"Live Editing",id:"live-editing",level:3}],h={toc:d},p="wrapper";function c(e){let{components:t,...a}=e;return(0,i.kt)(p,(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This page assumes you have read through the ",(0,i.kt)("a",{parentName:"p",href:"./schema"},"Schema")," document. "),(0,i.kt)("p",null,"Posts are usually written in a hybrid of plain Markdown and HTML. This is necessary to support prose that contains styles different from the conventional formatting. It is beneficial to keep posts in the blog section as markdown or MDX files instead of writing the custom ones as standalone JS pages for organization as well as centralizing data in one area that is queried by the data layer. In addition, the posts can maintain a set of frontmatter that allows editors to modify and sort the pages more easily."),(0,i.kt)("h2",{id:"data-in-nextjs"},"Data in Next.js"),(0,i.kt)("h3",{id:"reading-data"},"Reading Data"),(0,i.kt)("p",null,"To display the markdown posts, they must be rendered through static site generation. Posts must be read from the file subsystem. A helper function in ",(0,i.kt)("inlineCode",{parentName:"p"},"lib/posts.js")," will identify all markdown files in the target directory and all of its subdirectories.  "),(0,i.kt)("h3",{id:"parsing"},"Parsing"),(0,i.kt)("p",null,"Next.js does not automatically parse the markdown files by default, so it is necessary to implement a markdown parser. A useful feature of Next over Jekyll is how extendible analyzing the data is because we have to implement this ourselves. Calla-Lily uses Grey Matter to extract the frontmatter from the markdown files, then parses the content beneath the frontmatter using Remark for plain markdown and unsanitized Rehype to maintain the HTML tags. In addition, we analyze the content for attributes such as word count and it is possible to extend this further for things such as number of paragraphs, sentences, etc. This is a feature that would be slightly challenging to do within TinaCMS while maintaining the performance that it grants editors because Next runs all of the data analysis at build time instead of runtime."),(0,i.kt)("p",null,"Anything related to data transformation or analysis is done in the ",(0,i.kt)("inlineCode",{parentName:"p"},"lib")," directory."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Analyzing the text in this implementation can even be used for word trends and AI purposes! Think recommendating stories based on the content of the current story!")),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"While the content is parsed in valid HTML in the contentHTML prop, it is not used to display the content of stories to the pages. Refer to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Other-People-UCSD/Calla-Lily/issues/27"},"issue #27")," resolved through the TinaCMS parsing strategy.")),(0,i.kt)("h2",{id:"data-in-tinacms"},"Data in TinaCMS"),(0,i.kt)("p",null,"TinaCMS queries the raw post data independently of the Next.js data transformations and analyses. It is possible to do the data parsing and analysis in the TinaCMS pipeline, but we keep it separate because of how Calla-Lily was built due to switching to a different headless CMS. When TinaCMS becomes not compatible with our website direction, not maintained anymore, or discontinued, it will be necessary to mount a new headless CMS to allow editors to publish to the website. "),(0,i.kt)("h3",{id:"reading-data-graphql"},"Reading Data: GraphQL"),(0,i.kt)("p",null,"Data that is referenced through the schema will automatically generate GraphQL queries with fields that point to the frontmatter keys and the content of the file. For many files such as the posts, the query will collect a page of fifty edges instead of all at once. To maintain this page-cache format, we iterate through the GraphQL query results and if there is another page, it gets queried for its results. ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Other-People-UCSD/Calla-Lily/issues/16"},"This issue was resolved in PR #17"),". "),(0,i.kt)("h3",{id:"parsing-1"},"Parsing"),(0,i.kt)("p",null,"We attempted to use the TinaMarkdown component to parse the markdown-HTML files, but TinaCMS v1.4 did not properly parse HTML tags. TinaMarkdown resulted in the HTML being seen as plaintext and rendered to the screen. This would have caused issues with almost all posts because images and styles would not be displayed. "),(0,i.kt)("p",null,"Instead, we use our own parsing component inspired by the TinaMarkdown component to perform the parsing we want. Because the component is rendering JSX instead of HTML, we cannot use Remark/Rehype to parse the data or it may display the HTML as plaintext as well. To solve this, we implement the html-react-parser plugin and use it to parse HTML blocks as well as inline HTML. Sometimes the content of a post that usually written in HTML might be called ",(0,i.kt)("inlineCode",{parentName:"p"},"invalid_markdown")," and this will also be parsed by the plugin. ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Other-People-UCSD/Calla-Lily/issues/27"},"This issue was resolved in PR #26"),"."),(0,i.kt)("h3",{id:"live-editing"},"Live Editing"),(0,i.kt)("p",null,"The main advantage of using the TinaCMS pipeline for most of the data is the live editing feature. The content is displayed next to the editable fields which makes it an excellent UI for editors to see how the story would look when it gets published. The focus on maintaining a fast runtime performance here is why the other data relations such as adjacent posts or word count are handled in Next.js because those are attributes that should not change often and aren't necessary for editors to change."))}c.isMDXComponent=!0}}]);